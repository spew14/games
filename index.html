<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spew14 Unblocked School Games</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Equivalent to Tailwind's gray-900 */
        }
        .font-press-start {
            font-family: 'Press Start 2P', cursive;
        }
        /* Custom scrollbar for a more "gamer" feel */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2d3748; /* gray-800 */
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568; /* gray-600 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #718096; /* gray-500 */
        }
        /* Prevent canvas/iframe from getting focus outline */
        canvas:focus, iframe:focus {
            outline: none;
        }
        /* Simple glow effect for title */
        .title-glow {
            text-shadow: 0 0 8px rgba(59, 130, 246, 0.5), 0 0 20px rgba(59, 130, 246, 0.3);
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <!-- Main Container -->
    <div id="app-container" class="container mx-auto p-4 sm:p-6 lg:p-8">
        
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl sm:text-5xl md:text-6xl font-press-start title-glow">UNBLOCKED GAMES</h1>
            <p class="text-gray-400 mt-2 text-sm sm:text-base">Classic Arcade Fun, Right in Your Browser</p>
        </header>

        <!-- Game Grid -->
        <main id="game-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 sm:gap-6">
            <!-- Game cards will be injected here by JavaScript -->
        </main>

        <!-- Game Player Container (Initially Hidden) -->
        <div id="game-player" class="hidden flex-col items-center justify-center">
            <div class="w-full max-w-4xl mx-auto">
                 <div class="flex justify-between items-center mb-4">
                    <h2 id="game-title" class="text-2xl sm:text-3xl font-press-start"></h2>
                    <button id="close-game" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out transform hover:scale-105">
                        &times; Close
                    </button>
                </div>
                <!-- This container will hold either a canvas or an iframe -->
                <div id="game-container" class="bg-black rounded-lg shadow-2xl overflow-hidden aspect-video">
                    <!-- Game will be inserted here -->
                </div>
                <div id="game-instructions" class="text-center text-gray-400 mt-4 p-4 bg-gray-800 rounded-lg">
                    <!-- Instructions will be inserted here -->
                </div>
            </div>
        </div>
        
        <!-- Footer -->
        <footer class="text-center mt-12 text-gray-500 text-sm">
            <p>&copy; 2025 School Arcade. All games are created for educational and entertainment purposes.</p>
        </footer>

    </div>

    <script>
        const gameGrid = document.getElementById('game-grid');
        const gamePlayer = document.getElementById('game-player');
        const appContainer = document.getElementById('app-container');
        const gameTitle = document.getElementById('game-title');
        const gameContainer = document.getElementById('game-container');
        const gameInstructions = document.getElementById('game-instructions');
        const closeGameBtn = document.getElementById('close-game');

        let currentGame = null;
        let animationFrameId = null;

        // --- GAME DEFINITIONS ---
        // To add a new game from an HTML file, just add a new object to this array with a 'url'.
        const games = [
            {
                id: 'placeholder-1',
                name: 'Your Game',
                icon: 'ðŸš€',
                instructions: 'Add your game\'s instructions here. The game should be in a file named "my-game.html".',
                url: 'my-game.html' // Example: Loads from an external HTML file
            },
            {
                id: 'buckshotroulette',
                name: 'Buckshot Roulette',
                icon: 'ðŸ‘¾',
                instructions: 'This tile is ready for another game file, like "another-game.html".',
                url: 'buckshot.html' // Example: Loads from an external HTML file
            },

        // --- CORE APP LOGIC ---

        function showGameGrid() {
            gameGrid.classList.remove('hidden');
            appContainer.querySelector('header').classList.remove('hidden');
            appContainer.querySelector('footer').classList.remove('hidden');
            gamePlayer.classList.add('hidden');
            gamePlayer.classList.remove('flex');
            
            // Clean up previous game
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            gameContainer.innerHTML = ''; // This clears canvas or iframe
            currentGame = null;
            document.removeEventListener('keydown', handleGlobalKeydown);
        }

        function launchGame(gameId) {
            const game = games.find(g => g.id === gameId);
            if (!game) return;
            
            currentGame = game;

            gameGrid.classList.add('hidden');
            appContainer.querySelector('header').classList.add('hidden');
            appContainer.querySelector('footer').classList.add('hidden');
            
            gamePlayer.classList.remove('hidden');
            gamePlayer.classList.add('flex');
            gameTitle.textContent = game.name;
            gameInstructions.textContent = game.instructions;

            gameContainer.innerHTML = ''; // Clear previous game content

            if (game.url) {
                // If the game has a URL, load it in an iframe
                const iframe = document.createElement('iframe');
                iframe.src = game.url;
                iframe.className = 'w-full h-full border-0';
                iframe.setAttribute('allowfullscreen', '');
                iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin'); // For security
                gameContainer.appendChild(iframe);
            } else if (game.init) {
                // If it has an init function, run the built-in game
                game.init();
            }
            
            document.addEventListener('keydown', handleGlobalKeydown);
        }
        
        function handleGlobalKeydown(e) {
            if (e.key === 'Escape') {
                showGameGrid();
            }
        }

        function createGameCards() {
            games.forEach(game => {
                const card = document.createElement('div');
                card.className = 'bg-gray-800 rounded-lg shadow-lg p-4 flex flex-col items-center justify-center text-center cursor-pointer transition duration-300 ease-in-out transform hover:scale-105 hover:bg-blue-600 aspect-square';
                card.innerHTML = `
                    <div class="text-5xl sm:text-6xl mb-2">${game.icon}</div>
                    <h3 class="font-semibold text-sm sm:text-base">${game.name}</h3>
                `;
                card.addEventListener('click', () => launchGame(game.id));
                gameGrid.appendChild(card);
            });
        }
        
        closeGameBtn.addEventListener('click', showGameGrid);


        // --- BUILT-IN GAME IMPLEMENTATIONS ---

        function createCanvas() {
            gameContainer.innerHTML = '';
            const canvas = document.createElement('canvas');
            canvas.className = 'w-full h-full';
            gameContainer.appendChild(canvas);
            const ctx = canvas.getContext('2d');
            
            const rect = gameContainer.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            return { canvas, ctx };
        }
        
        // --- TIC TAC TOE ---
        function runTicTacToeGame() {
            gameContainer.innerHTML = ''; // Not using canvas for this one
            const board = document.createElement('div');
            board.style.display = 'grid';
            board.style.gridTemplateColumns = 'repeat(3, 1fr)';
            board.style.width = '100%';
            board.style.height = '100%';
            board.style.gap = '5px';
            gameContainer.appendChild(board);

            let currentPlayer = 'X';
            let boardState = Array(9).fill(null);
            const cells = [];

            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.style.backgroundColor = '#2d3748'; // gray-800
                cell.style.display = 'flex';
                cell.style.alignItems = 'center';
                cell.style.justifyContent = 'center';
                cell.style.fontSize = 'min(15vw, 100px)';
                cell.style.fontFamily = "'Press Start 2P', cursive";
                cell.style.cursor = 'pointer';
                cell.style.borderRadius = '8px';
                cell.dataset.index = i;
                
                cell.addEventListener('click', handleCellClick);
                board.appendChild(cell);
                cells.push(cell);
            }

            function handleCellClick(e) {
                const index = parseInt(e.target.dataset.index);
                if (boardState[index] !== null) return;

                boardState[index] = currentPlayer;
                e.target.textContent = currentPlayer;
                e.target.style.color = currentPlayer === 'X' ? '#63b3ed' : '#f6ad55';

                if (checkWin(currentPlayer)) {
                    // NOTE: alert() can be disruptive. A custom modal would be a better UX.
                    setTimeout(() => { alert(`${currentPlayer} wins!`); resetGame(); }, 100);
                } else if (boardState.every(cell => cell !== null)) {
                    setTimeout(() => { alert('It\'s a draw!'); resetGame(); }, 100);
                } else {
                    currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                }
            }
            
            function checkWin(player) {
                const winConditions = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8],
                    [0, 3, 6], [1, 4, 7], [2, 5, 8],
                    [0, 4, 8], [2, 4, 6]
                ];
                return winConditions.some(combination => combination.every(index => boardState[index] === player));
            }

            function resetGame() {
                boardState.fill(null);
                cells.forEach(cell => { cell.textContent = ''; });
                currentPlayer = 'X';
            }
        }
        
        // --- SNAKE ---
        function runSnakeGame() {
            const { canvas, ctx } = createCanvas();
            // ... (Snake game logic remains the same)
            const gridSize = 20;
            let snake = [{ x: 10, y: 10 }];
            let food = {};
            let direction = { x: 0, y: -1 };
            let score = 0;
            let gameOver = false;
            let speed = 100;

            function placeFood() {
                food = {
                    x: Math.floor(Math.random() * (canvas.width / gridSize)),
                    y: Math.floor(Math.random() * (canvas.height / gridSize))
                };
            }
            
            document.addEventListener('keydown', e => {
                switch (e.key) {
                    case 'ArrowUp': if (direction.y === 0) direction = { x: 0, y: -1 }; break;
                    case 'ArrowDown': if (direction.y === 0) direction = { x: 0, y: 1 }; break;
                    case 'ArrowLeft': if (direction.x === 0) direction = { x: -1, y: 0 }; break;
                    case 'ArrowRight': if (direction.x === 0) direction = { x: 1, y: 0 }; break;
                }
            });

            function gameLoop() {
                if (gameOver) {
                    ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    ctx.fillRect(0,0,canvas.width, canvas.height);
                    ctx.fillStyle = 'white';
                    ctx.font = `bold ${canvas.width/15}px 'Press Start 2P'`;
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
                    ctx.font = `bold ${canvas.width/30}px 'Press Start 2P'`;
                    ctx.fillText(`Score: ${score}`, canvas.width / 2, canvas.height / 2 + 50);
                    return;
                }
                
                const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };
                snake.unshift(head);
                
                if (head.x < 0 || head.x >= canvas.width / gridSize || head.y < 0 || head.y >= canvas.height / gridSize) gameOver = true;
                for (let i = 1; i < snake.length; i++) {
                    if (head.x === snake[i].x && head.y === snake[i].y) gameOver = true;
                }
                
                if (head.x === food.x && head.y === food.y) {
                    score++;
                    placeFood();
                } else {
                    snake.pop();
                }

                ctx.fillStyle = '#1a202c';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'lime';
                snake.forEach(segment => ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize - 1, gridSize - 1));
                ctx.fillStyle = 'red';
                ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize - 1, gridSize - 1);

                setTimeout(gameLoop, speed);
            }
            placeFood();
            gameLoop();
        }

        // --- PONG ---
        function runPongGame() {
            const { canvas, ctx } = createCanvas();
            // ... (Pong game logic remains the same)
            const paddleHeight = canvas.height / 5;
            const paddleWidth = 10;
            let player = { x: 0, y: canvas.height / 2 - paddleHeight / 2, width: paddleWidth, height: paddleHeight, score: 0 };
            let ai = { x: canvas.width - paddleWidth, y: canvas.height / 2 - paddleHeight / 2, width: paddleWidth, height: paddleHeight, score: 0 };
            let ball = { x: canvas.width / 2, y: canvas.height / 2, radius: 7, speed: 5, dx: 5, dy: 5 };

            canvas.addEventListener('mousemove', e => {
                let rect = canvas.getBoundingClientRect();
                player.y = e.clientY - rect.top - player.height / 2;
                if (player.y < 0) player.y = 0;
                if (player.y > canvas.height - player.height) player.y = canvas.height - player.height;
            });

            function resetBall() {
                ball.x = canvas.width / 2;
                ball.y = canvas.height / 2;
                ball.speed = 5;
                ball.dx = (Math.random() > 0.5 ? 1 : -1) * ball.speed;
                ball.dy = (Math.random() * 2 - 1) * ball.speed;
            }

            function gameLoop() {
                ball.x += ball.dx;
                ball.y += ball.dy;

                if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) ball.dy *= -1;
                if (ball.x - ball.radius < player.x + player.width && ball.y > player.y && ball.y < player.y + player.height) {
                    ball.dx *= -1;
                    ball.speed += 0.2;
                }
                if (ball.x + ball.radius > ai.x && ball.y > ai.y && ball.y < ai.y + ai.height) ball.dx *= -1;

                if (ball.x - ball.radius < 0) { ai.score++; resetBall(); }
                if (ball.x + ball.radius > canvas.width) { player.score++; resetBall(); }

                ai.y += (ball.y - (ai.y + ai.height / 2)) * 0.1;
                if (ai.y < 0) ai.y = 0;
                if (ai.y > canvas.height - ai.height) ai.y = canvas.height - ai.height;

                ctx.fillStyle = '#1a202c';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 4;
                ctx.setLineDash([10, 10]);
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2, 0);
                ctx.lineTo(canvas.width / 2, canvas.height);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = 'white';
                ctx.fillRect(player.x, player.y, player.width, player.height);
                ctx.fillRect(ai.x, ai.y, ai.width, ai.height);
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.font = `bold ${canvas.width/10}px 'Press Start 2P'`;
                ctx.textAlign = 'center';
                ctx.fillText(player.score, canvas.width / 4, canvas.height / 5);
                ctx.fillText(ai.score, canvas.width * 3 / 4, canvas.height / 5);
                
                animationFrameId = requestAnimationFrame(gameLoop);
            }
            gameLoop();
        }
        
        // --- FLAPPY PIPE ---
        function runFlappyPipeGame() {
            const { canvas, ctx } = createCanvas();
            // ... (Flappy Pipe game logic remains the same)
            let bird = { x: 50, y: canvas.height / 2, width: 20, height: 20, velocity: 0 };
            const gravity = 0.3;
            const lift = -6;
            let pipes = [];
            const pipeWidth = 50;
            const pipeGap = 150;
            let frameCount = 0;
            let score = 0;
            let gameOver = false;

            document.addEventListener('keydown', e => { if (e.code === 'Space') bird.velocity = lift; });
            canvas.addEventListener('mousedown', () => bird.velocity = lift);

            function gameLoop() {
                if (gameOver) {
                    ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    ctx.fillRect(0,0,canvas.width, canvas.height);
                    ctx.fillStyle = 'white';
                    ctx.font = `bold ${canvas.width/15}px 'Press Start 2P'`;
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
                    ctx.font = `bold ${canvas.width/30}px 'Press Start 2P'`;
                    ctx.fillText(`Score: ${score}`, canvas.width / 2, canvas.height / 2 + 50);
                    return;
                }
                
                bird.velocity += gravity;
                bird.y += bird.velocity;
                if (frameCount % 100 === 0) {
                    const pipeY = Math.random() * (canvas.height - pipeGap - 100) + 50;
                    pipes.push({ x: canvas.width, y: pipeY });
                }
                frameCount++;
                pipes.forEach(pipe => { pipe.x -= 3; });
                pipes = pipes.filter(pipe => pipe.x + pipeWidth > 0);
                if (pipes.length > 0 && pipes[0].x + pipeWidth < bird.x && !pipes[0].passed) {
                    score++;
                    pipes[0].passed = true;
                }

                if (bird.y + bird.height > canvas.height || bird.y < 0) gameOver = true;
                pipes.forEach(pipe => {
                    if (bird.x < pipe.x + pipeWidth && bird.x + bird.width > pipe.x && (bird.y < pipe.y || bird.y + bird.height > pipe.y + pipeGap)) {
                        gameOver = true;
                    }
                });
                
                ctx.fillStyle = '#4a5568';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'yellow';
                ctx.fillRect(bird.x, bird.y, bird.width, bird.height);
                ctx.fillStyle = 'green';
                pipes.forEach(pipe => {
                    ctx.fillRect(pipe.x, 0, pipeWidth, pipe.y);
                    ctx.fillRect(pipe.x, pipe.y + pipeGap, pipeWidth, canvas.height - pipe.y - pipeGap);
                });
                ctx.fillStyle = 'white';
                ctx.font = `bold ${canvas.width/12}px 'Press Start 2P'`;
                ctx.textAlign = 'center';
                ctx.fillText(score, canvas.width / 2, canvas.height / 8);
                
                animationFrameId = requestAnimationFrame(gameLoop);
            }
            gameLoop();
        }
        
        // --- BREAKOUT ---
        function runBreakoutGame() {
            const { canvas, ctx } = createCanvas();
            // ... (Breakout game logic remains the same)
            let ball = { x: canvas.width / 2, y: canvas.height - 30, radius: 8, dx: 4, dy: -4 };
            let paddle = { height: 10, width: canvas.width/5, x: (canvas.width - canvas.width/5) / 2 };
            let score = 0;
            let gameOver = false;

            const brickRowCount = 5, brickColumnCount = 8;
            const brickWidth = canvas.width / (brickColumnCount + 1), brickHeight = 20, brickPadding = 5;
            const brickOffsetTop = 30, brickOffsetLeft = (canvas.width - (brickColumnCount * (brickWidth + brickPadding)))/2;

            let bricks = [];
            for (let c = 0; c < brickColumnCount; c++) {
                bricks[c] = [];
                for (let r = 0; r < brickRowCount; r++) {
                    bricks[c][r] = { x: 0, y: 0, status: 1 };
                }
            }
            
            canvas.addEventListener('mousemove', e => {
                let rect = canvas.getBoundingClientRect();
                let newX = e.clientX - rect.left;
                if(newX > 0 && newX < canvas.width) paddle.x = newX - paddle.width/2;
            });

            function collisionDetection() {
                for (let c = 0; c < brickColumnCount; c++) {
                    for (let r = 0; r < brickRowCount; r++) {
                        let b = bricks[c][r];
                        if (b.status == 1) {
                            if (ball.x > b.x && ball.x < b.x + brickWidth && ball.y > b.y && ball.y < b.y + brickHeight) {
                                ball.dy = -ball.dy;
                                b.status = 0;
                                score++;
                                if (score == brickRowCount * brickColumnCount) {
                                    alert("YOU WIN, CONGRATULATIONS!");
                                    showGameGrid();
                                }
                            }
                        }
                    }
                }
            }
            
            function drawBricks() {
                for (let c = 0; c < brickColumnCount; c++) {
                    for (let r = 0; r < brickRowCount; r++) {
                        if (bricks[c][r].status == 1) {
                            let brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
                            let brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
                            bricks[c][r].x = brickX;
                            bricks[c][r].y = brickY;
                            ctx.rect(brickX, brickY, brickWidth, brickHeight);
                            ctx.fillStyle = `hsl(${r * 360 / brickRowCount}, 70%, 50%)`;
                            ctx.fill();
                        }
                    }
                }
            }
            
            function gameLoop() {
                if(gameOver) return;

                ctx.fillStyle = '#1a202c';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.beginPath();
                drawBricks();
                ctx.closePath();

                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fillStyle = "white";
                ctx.fill();
                ctx.closePath();

                ctx.beginPath();
                ctx.rect(paddle.x, canvas.height - paddle.height, paddle.width, paddle.height);
                ctx.fillStyle = "#0095DD";
                ctx.fill();
                ctx.closePath();

                collisionDetection();
                
                ctx.font = `bold ${canvas.width/25}px 'Press Start 2P'`;
                ctx.fillStyle = "#FFF";
                ctx.fillText("Score: " + score, 8, 20);

                if (ball.x + ball.dx > canvas.width - ball.radius || ball.x + ball.dx < ball.radius) ball.dx = -ball.dx;
                if (ball.y + ball.dy < ball.radius) ball.dy = -ball.dy;
                else if (ball.y + ball.dy > canvas.height - ball.radius) {
                    if (ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
                        ball.dy = -ball.dy;
                    } else {
                        gameOver = true;
                        ctx.fillStyle = 'rgba(0,0,0,0.7)';
                        ctx.fillRect(0,0,canvas.width, canvas.height);
                        ctx.fillStyle = 'white';
                        ctx.font = `bold ${canvas.width/15}px 'Press Start 2P'`;
                        ctx.textAlign = 'center';
                        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
                        return;
                    }
                }

                ball.x += ball.dx;
                ball.y += ball.dy;
                
                animationFrameId = requestAnimationFrame(gameLoop);
            }
            gameLoop();
        }

        // --- INITIALIZE APP ---
        document.addEventListener('DOMContentLoaded', () => {
            createGameCards();
            showGameGrid();
        });
    </script>
</body>
</html>

